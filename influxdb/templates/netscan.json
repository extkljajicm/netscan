[{"apiVersion":"influxdata.com/v2alpha1","kind":"Label","metadata":{"name":"admiring-easley-516001"},"spec":{"color":"#ce58eb","name":"netscan"}},{"apiVersion":"influxdata.com/v2alpha1","kind":"Dashboard","metadata":{"name":"earning-shaw-516001"},"spec":{"associations":[{"kind":"Label","name":"admiring-easley-516001"}],"charts":[{"colors":[{"id":"base","name":"white","type":"text","hex":"#ffffff"}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Discovered Devices","queries":[{"query":"from(bucket: \"health\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"health_metrics\")\n  |> filter(fn: (r) => r[\"_field\"] == \"device_count\")\n  |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)\n  |> yield(name: \"max\")"}],"staticLegend":{},"width":2},{"axes":[{"base":"10","name":"x","scale":"linear"},{"base":"10","name":"y","scale":"linear"}],"colorizeRows":true,"colors":[{"id":"n-sHjsdyiIfjKmmgegHDy","name":"Do Androids Dream of Electric Sheep?","type":"scale","hex":"#8F8AF4"},{"id":"NwCEMOLXhWFQJ3laFXgP_","name":"Do Androids Dream of Electric Sheep?","type":"scale","hex":"#A51414"},{"id":"i1lHxMpr3ccoTCmJy2gEc","name":"Do Androids Dream of Electric Sheep?","type":"scale","hex":"#F4CF31"}],"geom":"line","height":4,"hoverDimension":"auto","kind":"Xy","legendColorizeRows":true,"legendOpacity":1,"legendOrientationThreshold":100000000,"name":"Bottom 10 RTT","opacity":1,"orientationThreshold":100000000,"position":"overlaid","queries":[{"query":"top10IPs = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"rtt_ms\")\n  |> filter(fn: (r) => r[\"_value\"] > 0)\n  |> group(columns: [\"ip\"]) \n  |> mean()\n  |> group()\n  |> sort(columns: [\"_value\"], desc: true)\n  |> limit(n: 10)\n  |> findColumn(fn: (key) => true, column: \"ip\") \n\n// --- Step 2: Get the time-series data for *only* those 10 IPs ---\nfrom(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"rtt_ms\")\n  |> filter(fn: (r) => r[\"_value\"] > 0)  \n  |> filter(fn: (r) => contains(value: r.ip, set: top10IPs))\n  |> group(columns: [\"ip\"]) \n  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false) \n  |> yield(name: \"mean\")"}],"staticLegend":{"colorizeRows":true,"opacity":1,"orientationThreshold":100000000,"widthRatio":1},"width":6,"widthRatio":1,"xCol":"_time","yCol":"_value","yPos":2},{"colors":[{"id":"base","name":"ruby","type":"text","hex":"#BF3D5E"},{"id":"1ozjE8u6nN_JbIWah4p7L","name":"ruby","type":"text","hex":"#BF3D5E","value":20},{"id":"_xONWLs0yeqgCxs94g6fI","name":"pool","type":"text","hex":"#22ADF6","value":50}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Good Devices","queries":[{"query":"from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> filter(fn: (r) => r[\"_value\"] == true)\n  |> group() // This is the fix: merges all data into one table\n  |> distinct(column: \"ip\") // Now finds all unique IPs from the single table\n  |> count() // Counts the total number of unique IPs"}],"staticLegend":{},"width":2,"xPos":2},{"colors":[{"id":"base","name":"honeydew","type":"text","hex":"#7CE490"},{"id":"EZmt6VJ_zdPzXF6mx69Gq","name":"ruby","type":"text","hex":"#BF3D5E","value":1}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Suspended Devices","queries":[{"query":"from(bucket: \"health\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"health_metrics\")\n  |> filter(fn: (r) => r[\"_field\"] == \"suspended_devices\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")"}],"staticLegend":{},"width":1,"xPos":4},{"colors":[{"id":"base","name":"viridian","type":"text","hex":"#32B08C"},{"id":"1ozjE8u6nN_JbIWah4p7L","name":"pineapple","type":"text","hex":"#FFB94A","value":1},{"id":"_xONWLs0yeqgCxs94g6fI","name":"fire","type":"text","hex":"#DC4E58","value":50}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Failed Devices","queries":[{"query":"from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> group(columns: [\"ip\"])  // Process each IP's data stream individually\n  |> sort(columns: [\"_time\"]) // Ensure records are in chronological order\n  \n  // Create a new column \"consecutive_failures\" that counts\n  // consecutive records where _value == false.\n  // The count resets to 0 when _value == true.\n  |> stateCount(fn: (r) => r._value == false, column: \"consecutive_failures\")\n  \n  // Filter for any record that was the 3rd (or more) consecutive failure\n  |> filter(fn: (r) => r.consecutive_failures >= 5)\n  \n  // Logic to get the final count\n  |> group() // Merge all tables\n  |> distinct(column: \"ip\") // Find all unique IPs that had a streak of 3+\n  |> count() // Count those unique IPs"}],"staticLegend":{},"width":1,"xPos":5},{"colors":[{"id":"base","name":"white","type":"text","hex":"#ffffff"}],"fieldOptions":[{"displayName":"_value","fieldName":"_value","visible":true}],"height":2,"kind":"Table","name":"Failed Devices Details","queries":[{"query":"from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> group(columns: [\"ip\"])  // Process each IP's data stream individually\n  |> sort(columns: [\"_time\"]) // Ensure records are in chronological order\n  \n  // Create a new column \"consecutive_failures\" that counts\n  // consecutive records where _value == false.\n  // The count resets to 0 when _value == true.\n  |> stateCount(fn: (r) => r._value == false, column: \"consecutive_failures\")\n  \n  // Filter for any record that was the 3rd (or more) consecutive failure\n  |> filter(fn: (r) => r.consecutive_failures >= 5)\n  \n  // Logic to get the final count\n  |> group() // Merge all tables\n  |> distinct(column: \"ip\") // Find all unique IPs that had a streak of 3+"}],"staticLegend":{},"tableOptions":{"verticalTimeAxis":true},"timeFormat":"YYYY-MM-DD HH:mm:ss","width":2,"xPos":6},{"axes":[{"base":"10","name":"x","scale":"linear"},{"base":"10","name":"y","scale":"linear"}],"colorizeRows":true,"colors":[{"id":"6iMU3heEMp7SU3MPv5pi_","name":"Atlantis","type":"scale","hex":"#74D495"},{"id":"u8y86dws73CQL14-dZT8E","name":"Atlantis","type":"scale","hex":"#3F3FBA"},{"id":"B-eG_lVkk-xVfEF_H9CkR","name":"Atlantis","type":"scale","hex":"#FF4D9E"}],"geom":"line","height":4,"hoverDimension":"auto","kind":"Xy","legendColorizeRows":true,"legendOpacity":1,"legendOrientationThreshold":100000000,"name":"Top 10 RTT","opacity":1,"orientationThreshold":100000000,"position":"overlaid","queries":[{"query":"top10IPs = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"rtt_ms\")\n  |> filter(fn: (r) => r[\"_value\"] > 0)  \n  |> group(columns: [\"ip\"]) \n  |> mean()\n  |> group()\n  |> sort(columns: [\"_value\"], desc: false)\n  |> limit(n: 10)\n  |> findColumn(fn: (key) => true, column: \"ip\") \n\n// --- Step 2: Get the time-series data for *only* those 10 IPs ---\nfrom(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"rtt_ms\")\n  |> filter(fn: (r) => r[\"_value\"] > 0)  \n  |> filter(fn: (r) => contains(value: r.ip, set: top10IPs))\n  |> group(columns: [\"ip\"]) \n  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false) \n  |> yield(name: \"mean\")"}],"staticLegend":{"colorizeRows":true,"opacity":1,"orientationThreshold":100000000,"widthRatio":1},"width":6,"widthRatio":1,"xCol":"_time","xPos":6,"yCol":"_value","yPos":2},{"colors":[{"id":"base","name":"ruby","type":"text","hex":"#BF3D5E"},{"id":"uaiBiacmZxTtR9d_TqSVi","name":"tiger","type":"text","hex":"#F48D38","value":70},{"id":"TbalyrA2jlG9qBOl-qgw1","name":"viridian","type":"text","hex":"#32B08C","value":99}],"decimalPlaces":2,"height":2,"kind":"Single_Stat","name":"Ping Success Rate (mean)","queries":[{"query":"// --- 1. Get Total Ping Count ---\n// This counts every ping attempt from the continuous monitor\ntotal_pings = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\") // This field exists on every attempt\n  |> group()\n  |> aggregateWindow(every: v.windowPeriod, fn: count, createEmpty: false)\n  |> map(fn: (r) => ({ _time: r._time, _value: float(v: r._value), _field: \"total_count\" }))\n\n// --- 2. Get Success Count ---\n// This counts only successful pings\nsuccessful_pings = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> filter(fn: (r) => r._value == true) // Only count the successes\n  |> group()\n  |> aggregateWindow(every: v.windowPeriod, fn: count, createEmpty: false)\n  |> map(fn: (r) => ({ _time: r._time, _value: float(v: r._value), _field: \"success_count\" }))\n\n// --- 3. Calculate the Percentage ---\njoin(tables: {total: total_pings, success: successful_pings}, on: [\"_time\"])\n  |> map(fn: (r) => ({\n      _time: r._time,\n      _field: \"ping_success_percentage\",\n      _value: if r._value_total > 0.0 then\n                  (r._value_success / r._value_total) * 100.0\n              else\n                  100.0\n  }))\n  // Cap the value at 100.0 (100%)\n  |> map(fn: (r) => ({ r with _value: if r._value > 100.0 then 100.0 else r._value }))\n\n// --- 4. Calculate the average of all percentages in the time range ---\n  |> mean() // <-- This is the new line\n\n|> yield(name: \"avg_ping_success_percentage\")"}],"staticLegend":{},"suffix":"%","width":2,"xPos":8},{"colors":[{"id":"base","name":"laser","type":"text","hex":"#00C9FF"}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Total ICMP Packets sent","queries":[{"query":"from(bucket: \"health\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"health_metrics\")\n  |> filter(fn: (r) => r[\"_field\"] == \"pings_sent_total\")\n  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)\n  |> yield(name: \"pings_per_second\")"}],"staticLegend":{},"width":2,"xPos":10}],"name":"Netscan"}}]