[{"apiVersion":"influxdata.com/v2alpha1","kind":"Label","metadata":{"name":"compassionate-goldwasser-ecc001"},"spec":{"color":"#ce58eb","name":"netscan"}},{"apiVersion":"influxdata.com/v2alpha1","kind":"Dashboard","metadata":{"name":"strange-noether-6cc001"},"spec":{"associations":[{"kind":"Label","name":"compassionate-goldwasser-ecc001"}],"charts":[{"colors":[{"id":"base","name":"white","type":"text","hex":"#ffffff"}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Discovered Devices","queries":[{"query":"from(bucket: \"health\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"health_metrics\")\n  |> filter(fn: (r) => r[\"_field\"] == \"device_count\")\n  |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)\n  |> yield(name: \"max\")"}],"staticLegend":{},"width":2},{"colors":[{"id":"base","name":"white","type":"text","hex":"#ffffff"}],"fieldOptions":[{"displayName":"ip","fieldName":"ip","visible":true}],"height":6,"kind":"Table","name":"IPs with no sysName","queries":[{"query":"import \"join\"\r\n\r\n// --- Step 1: Get all unique IPs from 'ping' in the selected time range ---\r\npingIPs = from(bucket: \"netscan\")\r\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\r\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\r\n  |> filter(fn: (r) => exists r.ip) // Ensure the 'ip' tag exists\r\n  |> keep(columns: [\"ip\"])\r\n  |> group() \r\n  |> distinct(column: \"ip\") // Output column is '_value'\r\n  // *** ADD THIS FIX: Rename _value back to ip ***\r\n  |> map(fn: (r) => ({ ip: r._value }))\r\n\r\n// --- Step 2: Get all unique IPs that *have* a hostname entry ---\r\nhostnameIPs = from(bucket: \"netscan\")\r\n  |> range(start: -30d, stop: now()) // Use a wide range\r\n  |> filter(fn: (r) => r[\"_measurement\"] == \"device_info\")\r\n  |> filter(fn: (r) => r[\"_field\"] == \"hostname\")\r\n  |> filter(fn: (r) => exists r.ip) \r\n  |> keep(columns: [\"ip\"])\r\n  |> group() \r\n  |> distinct(column: \"ip\") // Output column is '_value'\r\n  // *** MODIFY THIS FIX: Use r._value, not r.ip ***\r\n  |> map(fn: (r) => ({ ip: r._value, hasHostname: true })) // Create a marker column\r\n\r\n// --- Step 3: Join them and filter for IPs with no hostname ---\r\n// (This part is unchanged and should now work)\r\njoin.left(\r\n    left: pingIPs,\r\n    right: hostnameIPs,\r\n    on: (l, r) => l.ip == r.ip,\r\n    as: (l, r) => ({ ip: l.ip, hasHostname: r.hasHostname })\r\n)\r\n  |> filter(fn: (r) => not exists r.hasHostname)\r\n  |> keep(columns: [\"ip\"]) // Output just the IP\r\n  |> yield(name: \"ips_without_hostname\")"}],"staticLegend":{},"tableOptions":{"verticalTimeAxis":true},"timeFormat":"YYYY-MM-DD HH:mm:ss","width":2,"yPos":2},{"colors":[{"id":"base","name":"ruby","type":"text","hex":"#BF3D5E"},{"id":"1ozjE8u6nN_JbIWah4p7L","name":"ruby","type":"text","hex":"#BF3D5E","value":20},{"id":"_xONWLs0yeqgCxs94g6fI","name":"pool","type":"text","hex":"#22ADF6","value":50}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Good Devices","queries":[{"query":"from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> filter(fn: (r) => r[\"_value\"] == true)\n  |> group() // This is the fix: merges all data into one table\n  |> distinct(column: \"ip\") // Now finds all unique IPs from the single table\n  |> count() // Counts the total number of unique IPs"}],"staticLegend":{},"width":2,"xPos":2},{"colors":[{"id":"base","name":"white","type":"text","hex":"#ffffff"}],"fieldOptions":[{"displayName":"_value","fieldName":"_value","visible":true}],"height":6,"kind":"Table","name":"Failed Devices Details","note":"All Devices Up!","noteOnEmpty":true,"queries":[{"query":"from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> group(columns: [\"ip\"])  // Process each IP's data stream individually\n  |> sort(columns: [\"_time\"]) // Ensure records are in chronological order\n  \n  // Create a new column \"consecutive_failures\" that counts\n  // consecutive records where _value == false.\n  // The count resets to 0 when _value == true.\n  |> stateCount(fn: (r) => r._value == false, column: \"consecutive_failures\")\n  \n  // Filter for any record that was the 3rd (or more) consecutive failure\n  |> filter(fn: (r) => r.consecutive_failures >= 5)\n  \n  // Logic to get the final count\n  |> group() // Merge all tables\n  |> distinct(column: \"ip\") // Find all unique IPs that had a streak of 3+"}],"staticLegend":{},"tableOptions":{"verticalTimeAxis":true},"timeFormat":"YYYY-MM-DD HH:mm:ss","width":2,"xPos":2,"yPos":2},{"colors":[{"id":"base","name":"honeydew","type":"text","hex":"#7CE490"},{"id":"EZmt6VJ_zdPzXF6mx69Gq","name":"ruby","type":"text","hex":"#BF3D5E","value":1}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Suspended Devices","queries":[{"query":"from(bucket: \"health\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"health_metrics\")\n  |> filter(fn: (r) => r[\"_field\"] == \"suspended_devices\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")"}],"staticLegend":{},"width":1,"xPos":4},{"axes":[{"base":"10","name":"x","scale":"linear"},{"base":"10","name":"y","scale":"linear","suffix":"%"}],"colorizeRows":true,"colors":[{"id":"clMn3a1iQVXDnzqrIV9WV","name":"Color Blind Friendly - Light","type":"scale","hex":"#FFFFFF"},{"id":"4DUYOfC_pCvAs1Qh_Od2m","name":"Color Blind Friendly - Light","type":"scale","hex":"#E69F00"},{"id":"QfKhHkEylhjwxzWHfTW3S","name":"Color Blind Friendly - Light","type":"scale","hex":"#56B4E9"},{"id":"WUVPEYoHpqLdiECK3-HLl","name":"Color Blind Friendly - Light","type":"scale","hex":"#009E73"},{"id":"JXu8YHjqa68HFYrpAXlTh","name":"Color Blind Friendly - Light","type":"scale","hex":"#F0E442"},{"id":"v1PLGB3uC3IOUJ8eC0eBf","name":"Color Blind Friendly - Light","type":"scale","hex":"#0072B2"},{"id":"7V62GiY7eTNBq5deMJeOa","name":"Color Blind Friendly - Light","type":"scale","hex":"#D55E00"},{"id":"QNQZIzwJ6szmzsAcKOBhB","name":"Color Blind Friendly - Light","type":"scale","hex":"#CC79A7"}],"geom":"line","height":2,"hoverDimension":"auto","kind":"Xy","legendColorizeRows":true,"legendOpacity":1,"legendOrientationThreshold":100000000,"name":"Ping Success Rate","opacity":1,"orientationThreshold":100000000,"position":"overlaid","queries":[{"query":"// --- 1. Get Total Ping Count ---\ntotal_pings = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\") // This field exists on every attempt\n  |> group()\n  |> aggregateWindow(every: v.windowPeriod, fn: count, createEmpty: false)\n  |> map(fn: (r) => ({ _time: r._time, _value: float(v: r._value), _field: \"total_count\" }))\n\n// --- 2. Get Success Count ---\nsuccessful_pings = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> filter(fn: (r) => r._value == true) // Only count the successes\n  |> group()\n  |> aggregateWindow(every: v.windowPeriod, fn: count, createEmpty: false)\n  |> map(fn: (r) => ({ _time: r._time, _value: float(v: r._value), _field: \"success_count\" }))\n\n// --- 3. Calculate the Percentage ---\njoin(tables: {total: total_pings, success: successful_pings}, on: [\"_time\"])\n  |> map(fn: (r) => ({\n      _time: r._time,\n      _field: \"ping_success_percentage\",\n      _value: if r._value_total > 0.0 then\n                  (r._value_success / r._value_total) * 100.0\n              else\n                  100.0\n  }))\n  // Cap the value at 100.0 (100%)\n  |> map(fn: (r) => ({ r with _value: if r._value > 100.0 then 100.0 else r._value }))\n\n// --- 4. Add this line to smooth the graph ---\n  |> movingAverage(n: 11) // Averages the last 5 points.\n\n|> yield(name: \"ping_success_percentage\")"}],"staticLegend":{"colorizeRows":true,"opacity":1,"orientationThreshold":100000000,"widthRatio":1},"width":8,"widthRatio":1,"xCol":"_time","xPos":4,"yCol":"_value","yPos":2},{"colors":[{"id":"base","name":"viridian","type":"text","hex":"#32B08C"},{"id":"1ozjE8u6nN_JbIWah4p7L","name":"pineapple","type":"text","hex":"#FFB94A","value":1},{"id":"_xONWLs0yeqgCxs94g6fI","name":"fire","type":"text","hex":"#DC4E58","value":50}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Failed Devices","queries":[{"query":"from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> group(columns: [\"ip\"])  // Process each IP's data stream individually\n  |> sort(columns: [\"_time\"]) // Ensure records are in chronological order\n  \n  // Create a new column \"consecutive_failures\" that counts\n  // consecutive records where _value == false.\n  // The count resets to 0 when _value == true.\n  |> stateCount(fn: (r) => r._value == false, column: \"consecutive_failures\")\n  \n  // Filter for any record that was the 3rd (or more) consecutive failure\n  |> filter(fn: (r) => r.consecutive_failures >= 5)\n  \n  // Logic to get the final count\n  |> group() // Merge all tables\n  |> distinct(column: \"ip\") // Find all unique IPs that had a streak of 3+\n  |> count() // Count those unique IPs"}],"staticLegend":{},"width":1,"xPos":5},{"colors":[{"id":"base","name":"ruby","type":"text","hex":"#BF3D5E"},{"id":"uaiBiacmZxTtR9d_TqSVi","name":"tiger","type":"text","hex":"#F48D38","value":70},{"id":"TbalyrA2jlG9qBOl-qgw1","name":"viridian","type":"text","hex":"#32B08C","value":99}],"decimalPlaces":2,"height":2,"kind":"Single_Stat","name":"Ping Success Rate (mean)","queries":[{"query":"// --- 1. Get Total Ping Count ---\n// This counts every ping attempt from the continuous monitor\ntotal_pings = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\") // This field exists on every attempt\n  |> group()\n  |> aggregateWindow(every: v.windowPeriod, fn: count, createEmpty: false)\n  |> map(fn: (r) => ({ _time: r._time, _value: float(v: r._value), _field: \"total_count\" }))\n\n// --- 2. Get Success Count ---\n// This counts only successful pings\nsuccessful_pings = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> filter(fn: (r) => r._value == true) // Only count the successes\n  |> group()\n  |> aggregateWindow(every: v.windowPeriod, fn: count, createEmpty: false)\n  |> map(fn: (r) => ({ _time: r._time, _value: float(v: r._value), _field: \"success_count\" }))\n\n// --- 3. Calculate the Percentage ---\njoin(tables: {total: total_pings, success: successful_pings}, on: [\"_time\"])\n  |> map(fn: (r) => ({\n      _time: r._time,\n      _field: \"ping_success_percentage\",\n      _value: if r._value_total > 0.0 then\n                  (r._value_success / r._value_total) * 100.0\n              else\n                  100.0\n  }))\n  // Cap the value at 100.0 (100%)\n  |> map(fn: (r) => ({ r with _value: if r._value > 100.0 then 100.0 else r._value }))\n\n// --- 4. Calculate the average of all percentages in the time range ---\n  |> mean() // <-- This is the new line\n\n|> yield(name: \"avg_ping_success_percentage\")"}],"staticLegend":{},"suffix":"%","width":2,"xPos":6},{"colors":[{"id":"base","name":"laser","type":"text","hex":"#00C9FF"}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Total ICMP Packets sent","queries":[{"query":"from(bucket: \"health\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"health_metrics\")\n  |> filter(fn: (r) => r[\"_field\"] == \"pings_sent_total\")\n  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)\n  |> yield(name: \"pings_per_second\")"}],"staticLegend":{},"width":2,"xPos":8},{"colors":[{"id":"base","name":"viridian","type":"text","hex":"#32B08C"},{"id":"YwJHg33LkUZDF6cOhsNPN","name":"pineapple","type":"text","hex":"#FFB94A","value":500},{"id":"fAqvWS9ZxAS32rsPIlPcQ","name":"fire","type":"text","hex":"#DC4E58","value":1000}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Average Ping Duration [ms]","queries":[{"query":"from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"rtt_ms\")\n  |> filter(fn: (r) => r._value > 0.0)\n  |> group() // <-- Add this line to ungroup all devices\n  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)\n  |> yield(name: \"overall_average_rtt_ms\")"}],"staticLegend":{},"suffix":" ms","width":2,"xPos":10}],"name":"Netscan"}}]