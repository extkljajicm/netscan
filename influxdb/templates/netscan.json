[{"apiVersion":"influxdata.com/v2alpha1","kind":"Label","metadata":{"name":"musing-buck-d17001"},"spec":{"color":"#ce58eb","name":"netscan"}},{"apiVersion":"influxdata.com/v2alpha1","kind":"Dashboard","metadata":{"name":"cool-feynman-117001"},"spec":{"associations":[{"kind":"Label","name":"musing-buck-d17001"}],"charts":[{"colors":[{"id":"base","name":"white","type":"text","hex":"#ffffff"}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Discovered Devices","queries":[{"query":"from(bucket: \"health\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"health_metrics\")\n  |> filter(fn: (r) => r[\"_field\"] == \"device_count\")\n  |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)\n  |> yield(name: \"max\")"}],"staticLegend":{},"width":2},{"axes":[{"base":"10","name":"x","scale":"linear"},{"base":"10","name":"y","scale":"linear"}],"colorizeRows":true,"colors":[{"id":"n-sHjsdyiIfjKmmgegHDy","name":"Do Androids Dream of Electric Sheep?","type":"scale","hex":"#8F8AF4"},{"id":"NwCEMOLXhWFQJ3laFXgP_","name":"Do Androids Dream of Electric Sheep?","type":"scale","hex":"#A51414"},{"id":"i1lHxMpr3ccoTCmJy2gEc","name":"Do Androids Dream of Electric Sheep?","type":"scale","hex":"#F4CF31"}],"geom":"line","height":4,"hoverDimension":"auto","kind":"Xy","legendColorizeRows":true,"legendOpacity":1,"legendOrientationThreshold":100000000,"name":"Bottom 10 RTT","opacity":1,"orientationThreshold":100000000,"position":"overlaid","queries":[{"query":"top10IPs = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"rtt_ms\")\n  |> group(columns: [\"ip\"]) \n  |> mean()\n  |> group()\n  |> sort(columns: [\"_value\"], desc: true)\n  |> limit(n: 10)\n  |> findColumn(fn: (key) => true, column: \"ip\") \n\n// --- Step 2: Get the time-series data for *only* those 10 IPs ---\nfrom(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"rtt_ms\")\n  |> filter(fn: (r) => contains(value: r.ip, set: top10IPs))\n  |> group(columns: [\"ip\"]) \n  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false) \n  |> yield(name: \"mean\")"}],"staticLegend":{"colorizeRows":true,"opacity":1,"orientationThreshold":100000000,"widthRatio":1},"width":6,"widthRatio":1,"xCol":"_time","yCol":"_value","yPos":2},{"axes":[{"base":"10","name":"x","scale":"linear"},{"base":"10","name":"y","scale":"linear"}],"colorizeRows":true,"colors":[{"id":"q4oj-SqRt3YWeeVLpbaqT","name":"Nineteen Eighty Four","type":"scale","hex":"#31C0F6"},{"id":"nLBzZpbBbRjZkNv4WDb-5","name":"Nineteen Eighty Four","type":"scale","hex":"#A500A5"},{"id":"dqTpbT4tgL7TfiuWdVfzw","name":"Nineteen Eighty Four","type":"scale","hex":"#FF7E27"},{"id":"base","name":"ruby","type":"text","hex":"#BF3D5E"},{"id":"_ORYnYE-uT082AmKCTdNj","name":"tiger","type":"text","hex":"#F48D38","value":60},{"id":"tq8_Lo2qdrZMznfv9vPiO","name":"thunder","type":"text","hex":"#FFD255","value":80},{"id":"gK-NlM835WmyUJU8LtG4W","name":"viridian","type":"text","hex":"#32B08C","value":95}],"decimalPlaces":0,"height":2,"heightRatio":0.15422077922077923,"hoverDimension":"auto","kind":"Single_Stat_Plus_Line","legendColorizeRows":true,"legendOpacity":1,"legendOrientationThreshold":-1,"name":"Ping Success Rate","opacity":1,"orientationThreshold":100000000,"position":"overlaid","queries":[{"query":"// --- 1. Get Success Count ---\n// This counts all successful pings (rtt_ms > 0) in the window.\nsuccess_count = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"rtt_ms\")\n  |> filter(fn: (r) => r._value > 0.0)\n  |> group()\n  |> aggregateWindow(every: v.windowPeriod, fn: count, createEmpty: false)\n  |> map(fn: (r) => ({ _time: r._time, _value: float(v: r._value), _field: \"success_count\" }))\n\n// --- 2. Get Sent Count ---\n// This gets the total number of pings sent during the window\n// by subtracting the first counter value from the last.\nsent_count = from(bucket: \"health\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"health_metrics\")\n  |> filter(fn: (r) => r[\"_field\"] == \"pings_sent_total\")\n  |> group()\n  |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)\n  |> map(fn: (r) => ({ _time: r._time, _value: float(v: r._value), _field: \"sent_count\" }))\n\n// --- 3. Calculate the Percentage ---\njoin(tables: {success: success_count, sent: sent_count}, on: [\"_time\"])\n  |> map(fn: (r) => ({\n      _time: r._time,\n      _field: \"ping_success_percentage\",\n      _value: if r._value_sent > 0.0 then\n                  // Changed to percentage\n                  (r._value_success / r._value_sent) * 100.0\n              else\n                  // Changed to 100%\n                  100.0\n  }))\n  // Cap the value at 100.0 (100%)\n  |> map(fn: (r) => ({ r with _value: if r._value > 100.0 then 100.0 else r._value }))\n\n|> yield(name: \"ping_success_percentage\")"}],"staticLegend":{"colorizeRows":true,"heightRatio":0.15422077922077923,"opacity":1,"orientationThreshold":100000000,"widthRatio":1},"suffix":"%","width":2,"widthRatio":1,"xCol":"_time","xPos":2,"yCol":"_value"},{"colors":[{"id":"base","name":"viridian","type":"text","hex":"#32B08C"},{"id":"1ozjE8u6nN_JbIWah4p7L","name":"pineapple","type":"text","hex":"#FFB94A","value":1},{"id":"_xONWLs0yeqgCxs94g6fI","name":"fire","type":"text","hex":"#DC4E58","value":50}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Failed Devices","queries":[{"query":"from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> group(columns: [\"ip\"])  // Process each IP's data stream individually\n  |> sort(columns: [\"_time\"]) // Ensure records are in chronological order\n  \n  // Create a new column \"consecutive_failures\" that counts\n  // consecutive records where _value == false.\n  // The count resets to 0 when _value == true.\n  |> stateCount(fn: (r) => r._value == false, column: \"consecutive_failures\")\n  \n  // Filter for any record that was the 3rd (or more) consecutive failure\n  |> filter(fn: (r) => r.consecutive_failures >= 5)\n  \n  // Logic to get the final count\n  |> group() // Merge all tables\n  |> distinct(column: \"ip\") // Find all unique IPs that had a streak of 3+\n  |> count() // Count those unique IPs"}],"staticLegend":{},"width":2,"xPos":4},{"colors":[{"id":"base","name":"white","type":"text","hex":"#ffffff"}],"fieldOptions":[{"displayName":"_value","fieldName":"_value","visible":true}],"height":2,"kind":"Table","name":"Failed Devices Details","queries":[{"query":"from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> group(columns: [\"ip\"])  // Process each IP's data stream individually\n  |> sort(columns: [\"_time\"]) // Ensure records are in chronological order\n  \n  // Create a new column \"consecutive_failures\" that counts\n  // consecutive records where _value == false.\n  // The count resets to 0 when _value == true.\n  |> stateCount(fn: (r) => r._value == false, column: \"consecutive_failures\")\n  \n  // Filter for any record that was the 3rd (or more) consecutive failure\n  |> filter(fn: (r) => r.consecutive_failures >= 5)\n  \n  // Logic to get the final count\n  |> group() // Merge all tables\n  |> distinct(column: \"ip\") // Find all unique IPs that had a streak of 3+"}],"staticLegend":{},"tableOptions":{"verticalTimeAxis":true},"timeFormat":"YYYY-MM-DD HH:mm:ss","width":3,"xPos":6},{"axes":[{"base":"10","name":"x","scale":"linear"},{"base":"10","name":"y","scale":"linear"}],"colorizeRows":true,"colors":[{"id":"6iMU3heEMp7SU3MPv5pi_","name":"Atlantis","type":"scale","hex":"#74D495"},{"id":"u8y86dws73CQL14-dZT8E","name":"Atlantis","type":"scale","hex":"#3F3FBA"},{"id":"B-eG_lVkk-xVfEF_H9CkR","name":"Atlantis","type":"scale","hex":"#FF4D9E"}],"geom":"line","height":4,"hoverDimension":"auto","kind":"Xy","legendColorizeRows":true,"legendOpacity":1,"legendOrientationThreshold":100000000,"name":"Top 10 RTT","opacity":1,"orientationThreshold":100000000,"position":"overlaid","queries":[{"query":"top10IPs = from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"rtt_ms\")\n  |> group(columns: [\"ip\"]) \n  |> mean()\n  |> group()\n  |> sort(columns: [\"_value\"], desc: false)\n  |> limit(n: 10)\n  |> findColumn(fn: (key) => true, column: \"ip\") \n\n// --- Step 2: Get the time-series data for *only* those 10 IPs ---\nfrom(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"rtt_ms\")\n  |> filter(fn: (r) => contains(value: r.ip, set: top10IPs))\n  |> group(columns: [\"ip\"]) \n  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false) \n  |> yield(name: \"mean\")"}],"staticLegend":{"colorizeRows":true,"opacity":1,"orientationThreshold":100000000,"widthRatio":1},"width":6,"widthRatio":1,"xCol":"_time","xPos":6,"yCol":"_value","yPos":2},{"colors":[{"id":"base","name":"ruby","type":"text","hex":"#BF3D5E"},{"id":"1ozjE8u6nN_JbIWah4p7L","name":"ruby","type":"text","hex":"#BF3D5E","value":20},{"id":"_xONWLs0yeqgCxs94g6fI","name":"pool","type":"text","hex":"#22ADF6","value":50}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Good Devices","queries":[{"query":"from(bucket: \"netscan\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"ping\")\n  |> filter(fn: (r) => r[\"_field\"] == \"success\")\n  |> filter(fn: (r) => r[\"_value\"] == true)\n  |> group() // This is the fix: merges all data into one table\n  |> distinct(column: \"ip\") // Now finds all unique IPs from the single table\n  |> count() // Counts the total number of unique IPs"}],"staticLegend":{},"width":2,"xPos":9},{"colors":[{"id":"base","name":"honeydew","type":"text","hex":"#7CE490"},{"id":"EZmt6VJ_zdPzXF6mx69Gq","name":"ruby","type":"text","hex":"#BF3D5E","value":1}],"decimalPlaces":0,"height":2,"kind":"Single_Stat","name":"Suspended Devices","queries":[{"query":"from(bucket: \"health\")\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"health_metrics\")\n  |> filter(fn: (r) => r[\"_field\"] == \"suspended_devices\")\n  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)\n  |> yield(name: \"last\")"}],"staticLegend":{},"width":1,"xPos":11}],"name":"Netscan"}}]